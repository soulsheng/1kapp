<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> 
<html> 
<head> 
<script language="JavaScript"> 
  var prePage="end";
  var nextPage="01.htm";
  var testPage="end";
  var labPage="end";
  var libraryPage="end";
  var studyPage="end";
  var homePage="end";
	function showwin(url,winname,properties){
		window.open(url,winname,properties)
	}
</script> 
<meta http-equiv="Content-Type" content="text/html; charset=gb2312"> 

<title>5.5排序与查找</title> 
<link href="images/css.css" rel="stylesheet" type="text/css"> 
</head> 

<body topmargin="0">
<p align="center" class="t1"><br>
  排序与查找</p>
　　<img src="images/STAR.GIF" width="18" height="20">算法：指的是在有限步骤内求解某一问题所使用的一组定义明确的规则。一个算法应该具有以下五个重要的特征： 
<br>
　　　　<img src="images/STAR1.GIF" width="15" height="20">有穷性：一个算法必须保证执行有限步之后结束<br>
　　　　<img src="images/STAR1.GIF" width="15" height="20">确切性：算法的每一步骤必须有确切的定义<br>
　　　　<img src="images/STAR1.GIF" width="15" height="20">输入：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定义了初始条件<br>
　　　　<img src="images/STAR1.GIF" width="15" height="20">输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的<br>
　　　　<img src="images/STAR1.GIF" width="15" height="20">可行性：算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成<br>
<p align="center" class="t1">插入排序　</p>
<p>　　排序问题的输入是一个线形表（例如数组），要求对该线性表的元素做某种排列，使得线性表中每个元素都小于等于（或大于等于）它的后继者（递增或递减排序）。<br>
  <a href="ch5/ch5ex18.java" target="_blank">【例5-18】插入排序（Insertion Sort）</a>。<br>
  　　<img src="images/STAR.GIF" width="18" height="20">插入排序的基本思想是，经过i-1遍处理后，L[1..i-1]已经排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i]又是排好序的序列。<br>
  　　<img src="images/STAR.GIF" width="18" height="20">这里使用顺序比较的方法：<br>
  　　　　<img src="images/STAR1.GIF" width="15" height="20">比较L[i]和L[i-1]，如果L[i-1]≤ 
  L[i]，则L[1..i]已经排好序，本次处理就结束了；<br>
  　　　　<img src="images/STAR1.GIF" width="15" height="20">否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j] 
≤L[j+1]时为止。</p>
<p align="center"><br>
表5-3对4个元素进行插入排序</p>
<table width="29%" height="405" border="1" align="center" cellpadding="0" cellspacing="0">
  <tr> 
    <td colspan="4"><div align="center">（a）第一轮交换</div></td>
  </tr>
  <tr> 
    <td width="28%"><div align="center">4</div></td>
    <td width="26%"><div align="center">3</div></td>
    <td width="27%"><div align="center">1</div></td>
    <td width="19%"><div align="center">2</div></td>
  </tr>
  <tr> 
    <td><div align="center">4 </div></td>
    <td><div align="center">　</div></td>
    <td><div align="center">1 </div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td><div align="center">　</div></td>
    <td><div align="center">4</div></td>
    <td><div align="center">1</div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
    <td><div align="center">1</div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td height="18" colspan="4"> <div align="center"></div>
      <div align="center"></div>
      <div align="center"></div>
      <div align="center">（b）第二轮交换</div></td>
  </tr>
  <tr> 
    <td><div align="center">4</div></td>
    <td><div align="center">3</div></td>
    <td><div align="center">1</div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
    <td><div align="center">　</div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td><div align="center">　</div></td>
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td height="25">
<div align="center">1</div></td>
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td height="12" colspan="4">
<div align="center"></div>
      <div align="center"></div>
      <div align="center"></div>
      <div align="center">（c）第三轮交换</div></td>
  </tr>
  <tr> 
    <td><div align="center">1</div></td>
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
    <td><div align="center">2</div></td>
  </tr>
  <tr> 
    <td><div align="center">1</div></td>
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
    <td><div align="center">　</div></td>
  </tr>
  <tr> 
    <td><div align="center">1</div></td>
    <td><div align="center">　</div></td>
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
  </tr>
  <tr> 
    <td><div align="center">1</div></td>
    <td><div align="center">2</div></td>
    <td><div align="center">3</div></td>
    <td><div align="center">4</div></td>
  </tr>
</table>
<p align="center" class="t1">快速排序</p>
　　<p><a href="ch5/ch5ex19.java" target="_blank">【例5-19】快速排序（Quick Sort）</a>。<br>
  　　<img src="images/STAR.GIF" width="18" height="20">快速排序的基本思想是基于分治策略的。对于输入的子序列L[p..r]，如果规模足够小则直接进行排序，否则分三步处理：<br>
  　　　　<img src="images/STAR1.GIF" width="15" height="20">分解：将输入的序列L[p..r]划分成两个非空子序列L[p..q]和L[q+1..r]，使L[p..q]中任一元素的值不大于L[q+1..r]中任一元素的值。<br>
  　　　　<img src="images/STAR1.GIF" width="15" height="20">递归求解：通过递归调用快速排序算法分别对L[p..q]和L[q+1..r]进行排序。<br>
  　　　　<img src="images/STAR1.GIF" width="15" height="20">合并：由于对分解出的两个子序列的排序是就地进行的，所以在L[p..q]和L[q+1..r]都排好序后不需要执行任何计算L[p..r]就已排好序。<br>
  　　<img src="images/STAR.GIF" width="18" height="20">快速排序方法示意图，图中0表示左边子序列的开始位置（结束位置为p-1），p表示右边子序列的开始位置（结束位置为a.length-1）。<br>
  <img src="images/05/054-1.jpg" width="462" height="67"><br>
  static void QuickSort(int a[],int low,int high){<br>
  　　int index[]=new int[2];//用于保存划分方法返回的结果<br>
  　　if(low&lt;high){//仅当区间长度大于1时才须排序<br>
  　　　　Partition(a,low,high,index);//对L[low..high]做划分<br>
  　　　　QuickSort(a,low,index[0]);//对左区间递归排序<br>
  　　　　QuickSort(a,index[1],high);//对右区间递归排序<br>
  　　}<br>
  }<br>
  　　<img src="images/STAR.GIF" width="18" height="20">算法QuickSort中调用了一个划分方法（Partition），其主要实现功能：<br>
  　　　　<img src="images/STAR1.GIF" width="15" height="20">在L[low..high-1]中选择一个基准元素pivot。<br>
  　　　　<img src="images/STAR1.GIF" width="15" height="20">对L[low..high-1]中的元素进行整理，使得L[low..high-1]分为三部分L[low.. 
  i]、L[j..high-1]以及i到j之间的等于基准元素pivot的区域，但是L[low..i]和L[j..high-1]中的元素并不要求排好序。<br>
　　<img src="images/STAR.GIF" width="18" height="20">示意图：　　</p>
<p align="center">
  <img src="images/05/054-2.jpg" width="495" height="48"><br>
  <img src="images/05/054-3.jpg" width="515" height="201">
</p>
<p align="center" class="t1">选择排序</p>
<a href="ch5/ch5ex20.java" target="_blank">【例5-20】选择排序（Selection Sort）</a>。<br>
<img src="images/STAR.GIF" width="18" height="20">选择排序的基本思想是对需要排序的元素序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个元素已经是排好序了。<br>
<p align="center" class="t1">顺序查找</p>
　　查找的定义是：给定一个值K，在含有n个元素的线形表（或数组）中找出等于给定值K的元素位置。若找到，则查找成功，否则查找失败，返回相关的指示信息。<br>
<a href="ch5/ch5ex21.java" target="_blank">【例5-21】顺序查找（Sequential Search）</a>。<br>
<img src="images/STAR.GIF" width="18" height="20">基本思想是：从表的一端开始，顺序扫描线性表，依次将扫描到的元素值和给定值K相比较。若当前扫描到的元素值与K相等，则查找成功；若扫描结束后，仍未找到元素值等于K的元素，则查找失败。<br>
<p align="center" class="t1">二分查找</p>
<a href="ch5/ch5ex22.java" target="_blank">【例5-2２】二分查找(Binary Search)</a>。<br>
　　二分查找要求：线性表是已经通过排序，是一个递增或递减的有序表，设L[low..high]是当前的查找区间,则二分查找的基本思想是：<br>
<img src="images/STAR.GIF" width="18" height="20">首先确定该区间的中点位置：mid=(int)((low+high)/2)<br>
<img src="images/STAR.GIF" width="18" height="20">然后将待查的K值与L[mid]比较，若相等，则查找成功并返回此位置，否则需要确定新的查找区间，继续二分查找，具体方法如下：<br>
　　　　<img src="images/STAR1.GIF" width="15" height="20">若L[mid]&gt;K，则由表的有序性可知L[mid..high]均大于K，因此若表中存在元素等于K的元素，则该元素必定是在位置mid左边的子表L[low..mid-1]中，故新的查找区间是左子表L[low..mid-1]。<br>
　　　　<img src="images/STAR1.GIF" width="15" height="20">类似地，若L[mid]&lt;K，则要查找的K必在mid的右子表R[mid+1..high]中，即新的查找区间是右子表L[mid+1..high]。下一次查找是针对新的查找区间进行的。 
</body> 
</html> 
